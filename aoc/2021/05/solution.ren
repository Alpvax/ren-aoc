import "ren/array" as Array exposing { #continue, #stop }
import "ren/compare" as Compare
import "ren/console" as Console
import "ren/file" as File
import "ren/math" as Math
import "ren/maybe" as Maybe exposing { #just, #nothing }
import "ren/object" as Object
import "ren/string" as String
import "ren/result" as Result exposing { #ok, #err}

pub fun main = [ year, day, part, test ] => {
    let input = if Logic.not test
        then File.open "./input.txt" { sync: true } |> Result.map (String.split "\\n")
        else #ok [
            "0,9 -> 5,9",
            "8,0 -> 0,8",
            "9,4 -> 3,4",
            "2,2 -> 2,1",
            "7,0 -> 7,4",
            "6,4 -> 2,0",
            "0,9 -> 2,9",
            "3,4 -> 1,4",
            "0,0 -> 8,8",
            "5,5 -> 8,2"
        ]

    ret when input
        is #ok lines => {
            let vents = parseInput lines
            ret when String.toNumber part
                is #just 1 => solvePartOne vents
                is #just 2 => solvePartTwo vents
                else => Console.warn `Unknown part: "${part}".`
        }
        is #err e => Console.error e
}

enum Vent
    // x [y0, y1]
    = #vertical _ _
    // y [x0, x1]
    | #horizontal _ _
    // yAxisIntersect, x0, magnitude
    // [1,1], [2,2] => 0, 1, 1; [3,6], [7,2] => 0, 3, -4(-5?);
    | #diagonal _ _ _

let diagonalX = fun y [yIntersect, x0, magnitude] => {
    let [yMin, yMax] = Array.sort [x0 + yIntersect, x0 + yIntersect + magnitude]
    ret if yMin <= y && y <= yMax
        then #just (Math.abs (y - yIntersect))
        else #nothing
}

let getOverlap = fun lineA lineB => {
    let xRange = fun x y0 y1 => Array.map (fun y => [x, y]) (Array.range y0 (y1 - y0 + 1))
    let yRange = fun y x0 x1 => Array.map (fun x => [x, y]) (Array.range x0 (x1 - x0 + 1))
    let sortedLines = Array.sortBy
        (fun line => when line
            is #diagonal _ _ m => if m > 0 then 1.5 else 1 //First (positive before negative gradient)
            is #vertical _ _ => 2
            is #horizontal _ _ => 3
        )
        [lineA, lineB]
    let overlaps = when sortedLines
        // [||]
        is [#vertical xA [minYA, maxYA], #vertical xB [minYB, maxYB]] =>
            if xA == xB then #just (xRange xA (Math.max minYA minYB) (Math.min maxYA maxYB)) else #nothing
        // [--]
        is [#horizontal yA [minXA, maxXA], #horizontal yB [minXB, maxXB]] =>
            if yA == yB then #just (yRange yA (Math.max minXA minXB) (Math.min maxXA maxXB)) else #nothing

        // [|-] (Should include [-|] due to sorting)
        is [#vertical xA [minYA, maxYA], #horizontal yB [minXB, maxXB]] =>
            if minXB <= xA && xA <= maxXB && minYA <= yB && yB <= maxYA then #just [[xA, yB]] else #nothing

// Should be impossible due to sorting
//        is [#horizontal yA [minXA, maxXA], #vertical xB [minYB, maxYB]] =>
//            if minXA <= xB && xB <= maxXA && minYB <= yA && yA <= maxYB then #just [[xB, yA]] else #nothing

        // [/|] (Should include [|/] due to sorting)
        is [#diagonal yIA xA mA, #vertical xB [minYB, maxYB]] =>
            if xA <= xB && xB <= xA + (Math.abs mA) then {
                let diagY = yIA + xA * mA
                ret if minYB <= diagY && diagY <= maxYB then [[xB, diagY]] else #nothing
            } else #nothing

// Should be impossible due to sorting
//        is [#vertical xA [minYA, maxYA], #diagonal yIB xB, mB] =>
//            if xB <= xA && xA <= xB + (Math.abs mB) then {
//                let diagY = yIB + xB * mB
//                ret if minYA <= diagY && diagY <= maxYA then [[xA, diagY]] else #nothing
//            } else #nothing

        // [/-] (Should include [-/] due to sorting)
        is [#diagonal yIA xA mA, #horizontal yB [minXB, maxXB]] =>
            Maybe.andThen
                (fun diagX => if minXB <= diagX && diagX <= maxXB then [diagX, yB] else )
                (diagonalX yB [yIA xA mA])

// Should be impossible due to sorting
//        is [#horizontal yA [minXA, maxXA], #diagonal yIB xB, mB] =>
//            if yB <= yA && yA <= yB + mB then {
//                let diagX = yB + (xA - xB) * mA
//                ret if minXA <= diagX && diagX <= maxXA then [[diagX, yA]]
//            } else #nothing

        // [//]
        is [#diagonal yIA xA mA, #diagonal yIB xB mB] => {
            let maxXA = xA + Math.abs mA
            let maxXB = xB + Math.abs mB
            ret if xA <= maxXB && xB <= maxXA
            then
                if Math.sign mA == Math.sign mB // Parallel
                then
                    if yIA == yIB
                    then #just {
                        let minX = Math.max xA xB
                        ret Array.range minX ((Math.min maxXA maxXB) - minX + 1)
                            |> Array.map (fun x => [x, x + yIA])
                    }
                    else #nothing
                else { // Perpendicular (A should be positive, B negative)
                    let x = (yIB - yIA) / 2
                    ret if xA <= x && xB <= x && x <= maxXA && x <= maxXB
                    then [[x, yIA + x]]
                    else #nothing
                }
            else #nothing
        }

        else => {
            let _ = Console.log ["Not implemented for lines", lineA, lineB]
            ret #nothing
        }
    ret overlaps
}

let parseInput = fun lines =>
    Array.foldr (fun vents line => if String.isEmpty line then vents else {
        let ends = String.split " -> " line
            |> Array.map ((String.split ",") >> (Array.map (String.toNumber >> Maybe.unwrap)))
        let ordered = fun a b => [Math.min a b, Math.max a b]
        let vent = if ends[0][0] == ends[1][0]
            then #vertical ends[0][0] (ordered ends[0][1] ends[1][1])
            else if ends[0][1] == ends[1][1]
                then #horizontal ends[0][1] (ordered ends[0][0] ends[1][0])
                else (
                    if ends[0][0] < ends[1][0]
                        then #diagonal (ends[1][1] - ends[0][1]) ends[0]
                        else #diagonal (ends[0][1] - ends[1][1]) ends[1]
                )
        let _ = Console.log `${line} => ${vent}`
        ret vent :: vents
    }) [] lines

let findIntersections = fun vents => {
    let [intersections, _] = Array.foldl (fun [intersections, uncheckedVents] vent => {
        let remainingUnchecked = Array.tail uncheckedVents
        let overlaps = Array.filterMap (fun v => getOverlap vent v) remainingUnchecked
        let flatOverlaps = Array.foldr (fun arr positions =>
            (Array.map (fun pos => `${pos[0]},${pos[1]}`) positions ) ++ arr)
            []
            overlaps
        ret [Array.unique (flatOverlaps ++ intersections), remainingUnchecked]
    }) [[], vents] vents
    ret intersections
}

let solvePartOne = fun vents => {
    let axialVents = Array.filter
        (fun v => when v
            is #diagonal _ => false
            else => true
        )
        vents
    let intersections = findIntersections axialVents
    let _ = Console.log intersections
    ret Array.length intersections
}

let solvePartTwo = fun vents => "UNIMPLEMENTED"
