import "ren/array" as Array exposing { #continue, #stop }
import "ren/compare" as Compare
import "ren/console" as Console
import "ren/file" as File
import "ren/math" as Math
import "ren/maybe" as Maybe exposing { #just, #nothing }
import "ren/object" as Object
import "ren/string" as String
import "ren/result" as Result exposing { #ok, #err}

pub fun main = [ year, day, part, test ] => {
    let input = if Logic.not test
        then File.open "./input.txt" { sync: true } |> Result.map (String.split "\\n")
        else #ok [
            "0,9 -> 5,9",
            "8,0 -> 0,8",
            "9,4 -> 3,4",
            "2,2 -> 2,1",
            "7,0 -> 7,4",
            "6,4 -> 2,0",
            "0,9 -> 2,9",
            "3,4 -> 1,4",
            "0,0 -> 8,8",
            "5,5 -> 8,2"
        ]

    ret when input
        is #ok lines => {
            let vents = parseInput lines
            ret when String.toNumber part
                is #just 1 => solvePartOne vents
                is #just 2 => solvePartTwo vents
                else => Console.warn `Unknown part: "${part}".`
        }
        is #err e => Console.error e
}

enum Vent
    // x [y0, y1]
    = #vertical _ _
    // y [x0, x1]
    | #horizontal _ _
    // [[x0, y0], [x1, y1]]
    | #diagonal _ _

let getOverlap = fun lineA lineB => {
    let xRange = fun x y0 y1 => Array.map (fun y => [x, y]) (Array.range y0 (y1 - y0 + 1))
    let yRange = fun y x0 x1 => Array.map (fun x => [x, y]) (Array.range x0 (x1 - x0 + 1))
    let overlaps = when [lineA, lineB]
        is [#vertical xA [minYA, maxYA], #vertical xB [minYB, maxYB]] =>
            if xA == xB then #just (xRange xA (Math.max minYA minYB) (Math.min maxYA maxYB)) else #nothing
        is [#horizontal yA [minXA, maxXA], #horizontal yB [minXB, maxXB]] =>
            if yA == yB then #just (yRange yA (Math.max minXA minXB) (Math.min maxXA maxXB)) else #nothing

        is [#vertical xA [minYA, maxYA], #horizontal yB [minXB, maxXB]] =>
            if minXB <= xA && xA <= maxXB && minYA <= yB && yB <= maxYA then #just [[xA, yB]] else #nothing
        is [#horizontal yA [minXA, maxXA], #vertical xB [minYB, maxYB]] =>
            if minXA <= xB && xB <= maxXA && minYB <= yA && yA <= maxYB then #just [[xB, yA]] else #nothing

        else => {
            let _ = Console.log "Not implemented for diagonanals"
            ret #nothing
        }
    ret overlaps
}

let parseInput = fun lines =>
    Array.foldr (fun vents line => if String.isEmpty line then vents else {
        let ends = String.split " -> " line
            |> Array.map ((String.split ",") >> (Array.map (String.toNumber >> Maybe.unwrap)))
        let ordered = fun a b => [Math.min a b, Math.max a b]
        let vent = if ends[0][0] == ends[1][0]
            then #vertical ends[0][0] (ordered ends[0][1] ends[1][1])
            else if ends[0][1] == ends[1][1]
                then #horizontal ends[0][1] (ordered ends[0][0] ends[1][0])
                else #diagonal (Array.map (String.join ",") ends)
        let _ = Console.log `${line} => ${vent}`
        ret vent :: vents
    }) [] lines

let solvePartOne = fun vents => {
    let axialVents = Array.filter
        (fun v => when v
            is #diagonal _ => false
            else => true
        )
        vents
    let [intersections, _] = Array.foldl (fun [intersections, uncheckedVents] vent => {
        let remainingUnchecked = Array.tail uncheckedVents
        let overlaps = Array.filterMap (fun v => getOverlap vent v) remainingUnchecked
        let flatOverlaps = Array.foldr (fun arr positions =>
            (Array.map (fun pos => `${pos[0]},${pos[1]}`) positions ) ++ arr)
            []
            overlaps
        ret [Array.unique (flatOverlaps ++ intersections), remainingUnchecked]
    }) [[], axialVents] axialVents
    let _ = Console.log intersections
    ret Array.length intersections
}

let solvePartTwo = fun vents => "UNIMPLEMENTED"
